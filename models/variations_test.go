// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"bytes"
	"reflect"
	"testing"

	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/randomize"
	"github.com/volatiletech/sqlboiler/strmangle"
)

func testVariations(t *testing.T) {
	t.Parallel()

	query := Variations(nil)

	if query.Query == nil {
		t.Error("expected a query, got nothing")
	}
}
func testVariationsDelete(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	if err = variation.Delete(tx); err != nil {
		t.Error(err)
	}

	count, err := Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 0 {
		t.Error("want zero records, got:", count)
	}
}

func testVariationsQueryDeleteAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	if err = Variations(tx).DeleteAll(); err != nil {
		t.Error(err)
	}

	count, err := Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 0 {
		t.Error("want zero records, got:", count)
	}
}

func testVariationsSliceDeleteAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	slice := VariationSlice{variation}

	if err = slice.DeleteAll(tx); err != nil {
		t.Error(err)
	}

	count, err := Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 0 {
		t.Error("want zero records, got:", count)
	}
}
func testVariationsExists(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	e, err := VariationExists(tx, variation.ID)
	if err != nil {
		t.Errorf("Unable to check if Variation exists: %s", err)
	}
	if !e {
		t.Errorf("Expected VariationExistsG to return true, but got false.")
	}
}
func testVariationsFind(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	variationFound, err := FindVariation(tx, variation.ID)
	if err != nil {
		t.Error(err)
	}

	if variationFound == nil {
		t.Error("want a record, got nil")
	}
}
func testVariationsBind(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	if err = Variations(tx).Bind(variation); err != nil {
		t.Error(err)
	}
}

func testVariationsOne(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	if x, err := Variations(tx).One(); err != nil {
		t.Error(err)
	} else if x == nil {
		t.Error("expected to get a non nil record")
	}
}

func testVariationsAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationOne := &Variation{}
	variationTwo := &Variation{}
	if err = randomize.Struct(seed, variationOne, variationDBTypes, false, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}
	if err = randomize.Struct(seed, variationTwo, variationDBTypes, false, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationOne.Insert(tx); err != nil {
		t.Error(err)
	}
	if err = variationTwo.Insert(tx); err != nil {
		t.Error(err)
	}

	slice, err := Variations(tx).All()
	if err != nil {
		t.Error(err)
	}

	if len(slice) != 2 {
		t.Error("want 2 records, got:", len(slice))
	}
}

func testVariationsCount(t *testing.T) {
	t.Parallel()

	var err error
	seed := randomize.NewSeed()
	variationOne := &Variation{}
	variationTwo := &Variation{}
	if err = randomize.Struct(seed, variationOne, variationDBTypes, false, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}
	if err = randomize.Struct(seed, variationTwo, variationDBTypes, false, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationOne.Insert(tx); err != nil {
		t.Error(err)
	}
	if err = variationTwo.Insert(tx); err != nil {
		t.Error(err)
	}

	count, err := Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 2 {
		t.Error("want 2 records, got:", count)
	}
}
func variationBeforeInsertHook(e boil.Executor, o *Variation) error {
	*o = Variation{}
	return nil
}

func variationAfterInsertHook(e boil.Executor, o *Variation) error {
	*o = Variation{}
	return nil
}

func variationAfterSelectHook(e boil.Executor, o *Variation) error {
	*o = Variation{}
	return nil
}

func variationBeforeUpdateHook(e boil.Executor, o *Variation) error {
	*o = Variation{}
	return nil
}

func variationAfterUpdateHook(e boil.Executor, o *Variation) error {
	*o = Variation{}
	return nil
}

func variationBeforeDeleteHook(e boil.Executor, o *Variation) error {
	*o = Variation{}
	return nil
}

func variationAfterDeleteHook(e boil.Executor, o *Variation) error {
	*o = Variation{}
	return nil
}

func variationBeforeUpsertHook(e boil.Executor, o *Variation) error {
	*o = Variation{}
	return nil
}

func variationAfterUpsertHook(e boil.Executor, o *Variation) error {
	*o = Variation{}
	return nil
}

func testVariationsHooks(t *testing.T) {
	t.Parallel()

	var err error

	empty := &Variation{}
	o := &Variation{}

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, o, variationDBTypes, false); err != nil {
		t.Errorf("Unable to randomize Variation object: %s", err)
	}

	AddVariationHook(boil.BeforeInsertHook, variationBeforeInsertHook)
	if err = o.doBeforeInsertHooks(nil); err != nil {
		t.Errorf("Unable to execute doBeforeInsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeInsertHook function to empty object, but got: %#v", o)
	}
	variationBeforeInsertHooks = []VariationHook{}

	AddVariationHook(boil.AfterInsertHook, variationAfterInsertHook)
	if err = o.doAfterInsertHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterInsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterInsertHook function to empty object, but got: %#v", o)
	}
	variationAfterInsertHooks = []VariationHook{}

	AddVariationHook(boil.AfterSelectHook, variationAfterSelectHook)
	if err = o.doAfterSelectHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterSelectHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterSelectHook function to empty object, but got: %#v", o)
	}
	variationAfterSelectHooks = []VariationHook{}

	AddVariationHook(boil.BeforeUpdateHook, variationBeforeUpdateHook)
	if err = o.doBeforeUpdateHooks(nil); err != nil {
		t.Errorf("Unable to execute doBeforeUpdateHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeUpdateHook function to empty object, but got: %#v", o)
	}
	variationBeforeUpdateHooks = []VariationHook{}

	AddVariationHook(boil.AfterUpdateHook, variationAfterUpdateHook)
	if err = o.doAfterUpdateHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterUpdateHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterUpdateHook function to empty object, but got: %#v", o)
	}
	variationAfterUpdateHooks = []VariationHook{}

	AddVariationHook(boil.BeforeDeleteHook, variationBeforeDeleteHook)
	if err = o.doBeforeDeleteHooks(nil); err != nil {
		t.Errorf("Unable to execute doBeforeDeleteHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeDeleteHook function to empty object, but got: %#v", o)
	}
	variationBeforeDeleteHooks = []VariationHook{}

	AddVariationHook(boil.AfterDeleteHook, variationAfterDeleteHook)
	if err = o.doAfterDeleteHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterDeleteHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterDeleteHook function to empty object, but got: %#v", o)
	}
	variationAfterDeleteHooks = []VariationHook{}

	AddVariationHook(boil.BeforeUpsertHook, variationBeforeUpsertHook)
	if err = o.doBeforeUpsertHooks(nil); err != nil {
		t.Errorf("Unable to execute doBeforeUpsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeUpsertHook function to empty object, but got: %#v", o)
	}
	variationBeforeUpsertHooks = []VariationHook{}

	AddVariationHook(boil.AfterUpsertHook, variationAfterUpsertHook)
	if err = o.doAfterUpsertHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterUpsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterUpsertHook function to empty object, but got: %#v", o)
	}
	variationAfterUpsertHooks = []VariationHook{}
}
func testVariationsInsert(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	count, err := Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}
}

func testVariationsInsertWhitelist(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx, variationColumnsWithoutDefault...); err != nil {
		t.Error(err)
	}

	count, err := Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}
}

func testVariationToManyEwDatabaseLinks(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c EwDatabaseLink

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, ewDatabaseLinkDBTypes, false, ewDatabaseLinkColumnsWithDefault...)
	randomize.Struct(seed, &c, ewDatabaseLinkDBTypes, false, ewDatabaseLinkColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	ewDatabaseLink, err := a.EwDatabaseLinks(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range ewDatabaseLink {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadEwDatabaseLinks(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.EwDatabaseLinks); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.EwDatabaseLinks = nil
	if err = a.L.LoadEwDatabaseLinks(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.EwDatabaseLinks); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", ewDatabaseLink)
	}
}

func testVariationToManyScheduleVariations(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c ScheduleVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, scheduleVariationDBTypes, false, scheduleVariationColumnsWithDefault...)
	randomize.Struct(seed, &c, scheduleVariationDBTypes, false, scheduleVariationColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	scheduleVariation, err := a.ScheduleVariations(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range scheduleVariation {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadScheduleVariations(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.ScheduleVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.ScheduleVariations = nil
	if err = a.L.LoadScheduleVariations(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.ScheduleVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", scheduleVariation)
	}
}

func testVariationToManySongDatabaseVariations(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c SongDatabaseVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, songDatabaseVariationDBTypes, false, songDatabaseVariationColumnsWithDefault...)
	randomize.Struct(seed, &c, songDatabaseVariationDBTypes, false, songDatabaseVariationColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	songDatabaseVariation, err := a.SongDatabaseVariations(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range songDatabaseVariation {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadSongDatabaseVariations(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SongDatabaseVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SongDatabaseVariations = nil
	if err = a.L.LoadSongDatabaseVariations(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SongDatabaseVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", songDatabaseVariation)
	}
}

func testVariationToManySRAddSongDatabaseVariations(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c SRAddSongDatabaseVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, srAddSongDatabaseVariationDBTypes, false, srAddSongDatabaseVariationColumnsWithDefault...)
	randomize.Struct(seed, &c, srAddSongDatabaseVariationDBTypes, false, srAddSongDatabaseVariationColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	srAddSongDatabaseVariation, err := a.SRAddSongDatabaseVariations(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range srAddSongDatabaseVariation {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadSRAddSongDatabaseVariations(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRAddSongDatabaseVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SRAddSongDatabaseVariations = nil
	if err = a.L.LoadSRAddSongDatabaseVariations(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRAddSongDatabaseVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", srAddSongDatabaseVariation)
	}
}

func testVariationToManySREwDatabaseLinks(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c SREwDatabaseLink

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, srEwDatabaseLinkDBTypes, false, srEwDatabaseLinkColumnsWithDefault...)
	randomize.Struct(seed, &c, srEwDatabaseLinkDBTypes, false, srEwDatabaseLinkColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	srEwDatabaseLink, err := a.SREwDatabaseLinks(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range srEwDatabaseLink {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadSREwDatabaseLinks(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SREwDatabaseLinks); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SREwDatabaseLinks = nil
	if err = a.L.LoadSREwDatabaseLinks(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SREwDatabaseLinks); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", srEwDatabaseLink)
	}
}

func testVariationToManySRNewVariations(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c SRNewVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, srNewVariationDBTypes, false, srNewVariationColumnsWithDefault...)
	randomize.Struct(seed, &c, srNewVariationDBTypes, false, srNewVariationColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	srNewVariation, err := a.SRNewVariations(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range srNewVariation {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadSRNewVariations(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRNewVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SRNewVariations = nil
	if err = a.L.LoadSRNewVariations(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRNewVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", srNewVariation)
	}
}

func testVariationToManySRRemoveSongDatabaseVariations(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c SRRemoveSongDatabaseVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, srRemoveSongDatabaseVariationDBTypes, false, srRemoveSongDatabaseVariationColumnsWithDefault...)
	randomize.Struct(seed, &c, srRemoveSongDatabaseVariationDBTypes, false, srRemoveSongDatabaseVariationColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	srRemoveSongDatabaseVariation, err := a.SRRemoveSongDatabaseVariations(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range srRemoveSongDatabaseVariation {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadSRRemoveSongDatabaseVariations(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRRemoveSongDatabaseVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SRRemoveSongDatabaseVariations = nil
	if err = a.L.LoadSRRemoveSongDatabaseVariations(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRRemoveSongDatabaseVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", srRemoveSongDatabaseVariation)
	}
}

func testVariationToManySRUpdatedEwDatabaseLinkVersions(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c SRUpdatedEwDatabaseLinkVersion

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, srUpdatedEwDatabaseLinkVersionDBTypes, false, srUpdatedEwDatabaseLinkVersionColumnsWithDefault...)
	randomize.Struct(seed, &c, srUpdatedEwDatabaseLinkVersionDBTypes, false, srUpdatedEwDatabaseLinkVersionColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	srUpdatedEwDatabaseLinkVersion, err := a.SRUpdatedEwDatabaseLinkVersions(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range srUpdatedEwDatabaseLinkVersion {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadSRUpdatedEwDatabaseLinkVersions(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRUpdatedEwDatabaseLinkVersions); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SRUpdatedEwDatabaseLinkVersions = nil
	if err = a.L.LoadSRUpdatedEwDatabaseLinkVersions(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRUpdatedEwDatabaseLinkVersions); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", srUpdatedEwDatabaseLinkVersion)
	}
}

func testVariationToManyTagVariations(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c TagVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, tagVariationDBTypes, false, tagVariationColumnsWithDefault...)
	randomize.Struct(seed, &c, tagVariationDBTypes, false, tagVariationColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	tagVariation, err := a.TagVariations(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range tagVariation {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadTagVariations(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.TagVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.TagVariations = nil
	if err = a.L.LoadTagVariations(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.TagVariations); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", tagVariation)
	}
}

func testVariationToManyVariationVersions(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c VariationVersion

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, variationVersionDBTypes, false, variationVersionColumnsWithDefault...)
	randomize.Struct(seed, &c, variationVersionDBTypes, false, variationVersionColumnsWithDefault...)

	b.VariationID = a.ID
	c.VariationID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	variationVersion, err := a.VariationVersions(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range variationVersion {
		if v.VariationID == b.VariationID {
			bFound = true
		}
		if v.VariationID == c.VariationID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationSlice{&a}
	if err = a.L.LoadVariationVersions(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.VariationVersions); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.VariationVersions = nil
	if err = a.L.LoadVariationVersions(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.VariationVersions); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", variationVersion)
	}
}

func testVariationToManyAddOpEwDatabaseLinks(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e EwDatabaseLink

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*EwDatabaseLink{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, ewDatabaseLinkDBTypes, false, strmangle.SetComplement(ewDatabaseLinkPrimaryKeyColumns, ewDatabaseLinkColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*EwDatabaseLink{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddEwDatabaseLinks(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.EwDatabaseLinks[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.EwDatabaseLinks[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.EwDatabaseLinks(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToManyAddOpScheduleVariations(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e ScheduleVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*ScheduleVariation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, scheduleVariationDBTypes, false, strmangle.SetComplement(scheduleVariationPrimaryKeyColumns, scheduleVariationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*ScheduleVariation{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddScheduleVariations(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.ScheduleVariations[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.ScheduleVariations[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.ScheduleVariations(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToManyAddOpSongDatabaseVariations(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e SongDatabaseVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SongDatabaseVariation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, songDatabaseVariationDBTypes, false, strmangle.SetComplement(songDatabaseVariationPrimaryKeyColumns, songDatabaseVariationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SongDatabaseVariation{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSongDatabaseVariations(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SongDatabaseVariations[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SongDatabaseVariations[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SongDatabaseVariations(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToManyAddOpSRAddSongDatabaseVariations(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e SRAddSongDatabaseVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SRAddSongDatabaseVariation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, srAddSongDatabaseVariationDBTypes, false, strmangle.SetComplement(srAddSongDatabaseVariationPrimaryKeyColumns, srAddSongDatabaseVariationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SRAddSongDatabaseVariation{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSRAddSongDatabaseVariations(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SRAddSongDatabaseVariations[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SRAddSongDatabaseVariations[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SRAddSongDatabaseVariations(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToManyAddOpSREwDatabaseLinks(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e SREwDatabaseLink

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SREwDatabaseLink{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, srEwDatabaseLinkDBTypes, false, strmangle.SetComplement(srEwDatabaseLinkPrimaryKeyColumns, srEwDatabaseLinkColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SREwDatabaseLink{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSREwDatabaseLinks(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SREwDatabaseLinks[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SREwDatabaseLinks[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SREwDatabaseLinks(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToManyAddOpSRNewVariations(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e SRNewVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SRNewVariation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, srNewVariationDBTypes, false, strmangle.SetComplement(srNewVariationPrimaryKeyColumns, srNewVariationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SRNewVariation{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSRNewVariations(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SRNewVariations[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SRNewVariations[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SRNewVariations(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToManyAddOpSRRemoveSongDatabaseVariations(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e SRRemoveSongDatabaseVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SRRemoveSongDatabaseVariation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, srRemoveSongDatabaseVariationDBTypes, false, strmangle.SetComplement(srRemoveSongDatabaseVariationPrimaryKeyColumns, srRemoveSongDatabaseVariationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SRRemoveSongDatabaseVariation{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSRRemoveSongDatabaseVariations(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SRRemoveSongDatabaseVariations[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SRRemoveSongDatabaseVariations[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SRRemoveSongDatabaseVariations(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToManyAddOpSRUpdatedEwDatabaseLinkVersions(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e SRUpdatedEwDatabaseLinkVersion

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SRUpdatedEwDatabaseLinkVersion{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, srUpdatedEwDatabaseLinkVersionDBTypes, false, strmangle.SetComplement(srUpdatedEwDatabaseLinkVersionPrimaryKeyColumns, srUpdatedEwDatabaseLinkVersionColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SRUpdatedEwDatabaseLinkVersion{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSRUpdatedEwDatabaseLinkVersions(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SRUpdatedEwDatabaseLinkVersions[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SRUpdatedEwDatabaseLinkVersions[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SRUpdatedEwDatabaseLinkVersions(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToManyAddOpTagVariations(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e TagVariation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*TagVariation{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, tagVariationDBTypes, false, strmangle.SetComplement(tagVariationPrimaryKeyColumns, tagVariationColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*TagVariation{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddTagVariations(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.TagVariations[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.TagVariations[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.TagVariations(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToManyAddOpVariationVersions(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c, d, e VariationVersion

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*VariationVersion{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*VariationVersion{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddVariationVersions(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationID {
			t.Error("foreign key was wrong value", a.ID, first.VariationID)
		}
		if a.ID != second.VariationID {
			t.Error("foreign key was wrong value", a.ID, second.VariationID)
		}

		if first.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.Variation != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.VariationVersions[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.VariationVersions[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.VariationVersions(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationToOneSongUsingSong(t *testing.T) {
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var local Variation
	var foreign Song

	seed := randomize.NewSeed()
	if err := randomize.Struct(seed, &local, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}
	if err := randomize.Struct(seed, &foreign, songDBTypes, false, songColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Song struct: %s", err)
	}

	local.SongID.Valid = true

	if err := foreign.Insert(tx); err != nil {
		t.Fatal(err)
	}

	local.SongID.Uint64 = foreign.ID
	if err := local.Insert(tx); err != nil {
		t.Fatal(err)
	}

	check, err := local.Song(tx).One()
	if err != nil {
		t.Fatal(err)
	}

	if check.ID != foreign.ID {
		t.Errorf("want: %v, got %v", foreign.ID, check.ID)
	}

	slice := VariationSlice{&local}
	if err = local.L.LoadSong(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if local.R.Song == nil {
		t.Error("struct should have been eager loaded")
	}

	local.R.Song = nil
	if err = local.L.LoadSong(tx, true, &local); err != nil {
		t.Fatal(err)
	}
	if local.R.Song == nil {
		t.Error("struct should have been eager loaded")
	}
}

func testVariationToOneLanguageUsingLanguage(t *testing.T) {
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var local Variation
	var foreign Language

	seed := randomize.NewSeed()
	if err := randomize.Struct(seed, &local, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}
	if err := randomize.Struct(seed, &foreign, languageDBTypes, false, languageColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Language struct: %s", err)
	}

	local.LanguageID.Valid = true

	if err := foreign.Insert(tx); err != nil {
		t.Fatal(err)
	}

	local.LanguageID.Uint64 = foreign.ID
	if err := local.Insert(tx); err != nil {
		t.Fatal(err)
	}

	check, err := local.Language(tx).One()
	if err != nil {
		t.Fatal(err)
	}

	if check.ID != foreign.ID {
		t.Errorf("want: %v, got %v", foreign.ID, check.ID)
	}

	slice := VariationSlice{&local}
	if err = local.L.LoadLanguage(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if local.R.Language == nil {
		t.Error("struct should have been eager loaded")
	}

	local.R.Language = nil
	if err = local.L.LoadLanguage(tx, true, &local); err != nil {
		t.Fatal(err)
	}
	if local.R.Language == nil {
		t.Error("struct should have been eager loaded")
	}
}

func testVariationToOneAuthorUsingAuthor(t *testing.T) {
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var local Variation
	var foreign Author

	seed := randomize.NewSeed()
	if err := randomize.Struct(seed, &local, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}
	if err := randomize.Struct(seed, &foreign, authorDBTypes, false, authorColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Author struct: %s", err)
	}

	local.AuthorID.Valid = true

	if err := foreign.Insert(tx); err != nil {
		t.Fatal(err)
	}

	local.AuthorID.Uint64 = foreign.ID
	if err := local.Insert(tx); err != nil {
		t.Fatal(err)
	}

	check, err := local.Author(tx).One()
	if err != nil {
		t.Fatal(err)
	}

	if check.ID != foreign.ID {
		t.Errorf("want: %v, got %v", foreign.ID, check.ID)
	}

	slice := VariationSlice{&local}
	if err = local.L.LoadAuthor(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if local.R.Author == nil {
		t.Error("struct should have been eager loaded")
	}

	local.R.Author = nil
	if err = local.L.LoadAuthor(tx, true, &local); err != nil {
		t.Fatal(err)
	}
	if local.R.Author == nil {
		t.Error("struct should have been eager loaded")
	}
}

func testVariationToOneCopyrightUsingCopyright(t *testing.T) {
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var local Variation
	var foreign Copyright

	seed := randomize.NewSeed()
	if err := randomize.Struct(seed, &local, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}
	if err := randomize.Struct(seed, &foreign, copyrightDBTypes, false, copyrightColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Copyright struct: %s", err)
	}

	local.CopyrightID.Valid = true

	if err := foreign.Insert(tx); err != nil {
		t.Fatal(err)
	}

	local.CopyrightID.Uint64 = foreign.ID
	if err := local.Insert(tx); err != nil {
		t.Fatal(err)
	}

	check, err := local.Copyright(tx).One()
	if err != nil {
		t.Fatal(err)
	}

	if check.ID != foreign.ID {
		t.Errorf("want: %v, got %v", foreign.ID, check.ID)
	}

	slice := VariationSlice{&local}
	if err = local.L.LoadCopyright(tx, false, (*[]*Variation)(&slice)); err != nil {
		t.Fatal(err)
	}
	if local.R.Copyright == nil {
		t.Error("struct should have been eager loaded")
	}

	local.R.Copyright = nil
	if err = local.L.LoadCopyright(tx, true, &local); err != nil {
		t.Fatal(err)
	}
	if local.R.Copyright == nil {
		t.Error("struct should have been eager loaded")
	}
}

func testVariationToOneSetOpSongUsingSong(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c Song

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, songDBTypes, false, strmangle.SetComplement(songPrimaryKeyColumns, songColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, songDBTypes, false, strmangle.SetComplement(songPrimaryKeyColumns, songColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}

	for i, x := range []*Song{&b, &c} {
		err = a.SetSong(tx, i != 0, x)
		if err != nil {
			t.Fatal(err)
		}

		if a.R.Song != x {
			t.Error("relationship struct not set to correct value")
		}

		if x.R.Variations[0] != &a {
			t.Error("failed to append to foreign relationship struct")
		}
		if a.SongID.Uint64 != x.ID {
			t.Error("foreign key was wrong value", a.SongID.Uint64)
		}

		zero := reflect.Zero(reflect.TypeOf(a.SongID.Uint64))
		reflect.Indirect(reflect.ValueOf(&a.SongID.Uint64)).Set(zero)

		if err = a.Reload(tx); err != nil {
			t.Fatal("failed to reload", err)
		}

		if a.SongID.Uint64 != x.ID {
			t.Error("foreign key was wrong value", a.SongID.Uint64, x.ID)
		}
	}
}

func testVariationToOneRemoveOpSongUsingSong(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b Song

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, songDBTypes, false, strmangle.SetComplement(songPrimaryKeyColumns, songColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err = a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	if err = a.SetSong(tx, true, &b); err != nil {
		t.Fatal(err)
	}

	if err = a.RemoveSong(tx, &b); err != nil {
		t.Error("failed to remove relationship")
	}

	count, err := a.Song(tx).Count()
	if err != nil {
		t.Error(err)
	}
	if count != 0 {
		t.Error("want no relationships remaining")
	}

	if a.R.Song != nil {
		t.Error("R struct entry should be nil")
	}

	if a.SongID.Valid {
		t.Error("foreign key value should be nil")
	}

	if len(b.R.Variations) != 0 {
		t.Error("failed to remove a from b's relationships")
	}
}

func testVariationToOneSetOpLanguageUsingLanguage(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c Language

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, languageDBTypes, false, strmangle.SetComplement(languagePrimaryKeyColumns, languageColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, languageDBTypes, false, strmangle.SetComplement(languagePrimaryKeyColumns, languageColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}

	for i, x := range []*Language{&b, &c} {
		err = a.SetLanguage(tx, i != 0, x)
		if err != nil {
			t.Fatal(err)
		}

		if a.R.Language != x {
			t.Error("relationship struct not set to correct value")
		}

		if x.R.Variations[0] != &a {
			t.Error("failed to append to foreign relationship struct")
		}
		if a.LanguageID.Uint64 != x.ID {
			t.Error("foreign key was wrong value", a.LanguageID.Uint64)
		}

		zero := reflect.Zero(reflect.TypeOf(a.LanguageID.Uint64))
		reflect.Indirect(reflect.ValueOf(&a.LanguageID.Uint64)).Set(zero)

		if err = a.Reload(tx); err != nil {
			t.Fatal("failed to reload", err)
		}

		if a.LanguageID.Uint64 != x.ID {
			t.Error("foreign key was wrong value", a.LanguageID.Uint64, x.ID)
		}
	}
}

func testVariationToOneRemoveOpLanguageUsingLanguage(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b Language

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, languageDBTypes, false, strmangle.SetComplement(languagePrimaryKeyColumns, languageColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err = a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	if err = a.SetLanguage(tx, true, &b); err != nil {
		t.Fatal(err)
	}

	if err = a.RemoveLanguage(tx, &b); err != nil {
		t.Error("failed to remove relationship")
	}

	count, err := a.Language(tx).Count()
	if err != nil {
		t.Error(err)
	}
	if count != 0 {
		t.Error("want no relationships remaining")
	}

	if a.R.Language != nil {
		t.Error("R struct entry should be nil")
	}

	if a.LanguageID.Valid {
		t.Error("foreign key value should be nil")
	}

	if len(b.R.Variations) != 0 {
		t.Error("failed to remove a from b's relationships")
	}
}

func testVariationToOneSetOpAuthorUsingAuthor(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c Author

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, authorDBTypes, false, strmangle.SetComplement(authorPrimaryKeyColumns, authorColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, authorDBTypes, false, strmangle.SetComplement(authorPrimaryKeyColumns, authorColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}

	for i, x := range []*Author{&b, &c} {
		err = a.SetAuthor(tx, i != 0, x)
		if err != nil {
			t.Fatal(err)
		}

		if a.R.Author != x {
			t.Error("relationship struct not set to correct value")
		}

		if x.R.Variations[0] != &a {
			t.Error("failed to append to foreign relationship struct")
		}
		if a.AuthorID.Uint64 != x.ID {
			t.Error("foreign key was wrong value", a.AuthorID.Uint64)
		}

		zero := reflect.Zero(reflect.TypeOf(a.AuthorID.Uint64))
		reflect.Indirect(reflect.ValueOf(&a.AuthorID.Uint64)).Set(zero)

		if err = a.Reload(tx); err != nil {
			t.Fatal("failed to reload", err)
		}

		if a.AuthorID.Uint64 != x.ID {
			t.Error("foreign key was wrong value", a.AuthorID.Uint64, x.ID)
		}
	}
}

func testVariationToOneRemoveOpAuthorUsingAuthor(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b Author

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, authorDBTypes, false, strmangle.SetComplement(authorPrimaryKeyColumns, authorColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err = a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	if err = a.SetAuthor(tx, true, &b); err != nil {
		t.Fatal(err)
	}

	if err = a.RemoveAuthor(tx, &b); err != nil {
		t.Error("failed to remove relationship")
	}

	count, err := a.Author(tx).Count()
	if err != nil {
		t.Error(err)
	}
	if count != 0 {
		t.Error("want no relationships remaining")
	}

	if a.R.Author != nil {
		t.Error("R struct entry should be nil")
	}

	if a.AuthorID.Valid {
		t.Error("foreign key value should be nil")
	}

	if len(b.R.Variations) != 0 {
		t.Error("failed to remove a from b's relationships")
	}
}

func testVariationToOneSetOpCopyrightUsingCopyright(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b, c Copyright

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, copyrightDBTypes, false, strmangle.SetComplement(copyrightPrimaryKeyColumns, copyrightColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, copyrightDBTypes, false, strmangle.SetComplement(copyrightPrimaryKeyColumns, copyrightColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}

	for i, x := range []*Copyright{&b, &c} {
		err = a.SetCopyright(tx, i != 0, x)
		if err != nil {
			t.Fatal(err)
		}

		if a.R.Copyright != x {
			t.Error("relationship struct not set to correct value")
		}

		if x.R.Variations[0] != &a {
			t.Error("failed to append to foreign relationship struct")
		}
		if a.CopyrightID.Uint64 != x.ID {
			t.Error("foreign key was wrong value", a.CopyrightID.Uint64)
		}

		zero := reflect.Zero(reflect.TypeOf(a.CopyrightID.Uint64))
		reflect.Indirect(reflect.ValueOf(&a.CopyrightID.Uint64)).Set(zero)

		if err = a.Reload(tx); err != nil {
			t.Fatal("failed to reload", err)
		}

		if a.CopyrightID.Uint64 != x.ID {
			t.Error("foreign key was wrong value", a.CopyrightID.Uint64, x.ID)
		}
	}
}

func testVariationToOneRemoveOpCopyrightUsingCopyright(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a Variation
	var b Copyright

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, copyrightDBTypes, false, strmangle.SetComplement(copyrightPrimaryKeyColumns, copyrightColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err = a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	if err = a.SetCopyright(tx, true, &b); err != nil {
		t.Fatal(err)
	}

	if err = a.RemoveCopyright(tx, &b); err != nil {
		t.Error("failed to remove relationship")
	}

	count, err := a.Copyright(tx).Count()
	if err != nil {
		t.Error(err)
	}
	if count != 0 {
		t.Error("want no relationships remaining")
	}

	if a.R.Copyright != nil {
		t.Error("R struct entry should be nil")
	}

	if a.CopyrightID.Valid {
		t.Error("foreign key value should be nil")
	}

	if len(b.R.Variations) != 0 {
		t.Error("failed to remove a from b's relationships")
	}
}

func testVariationsReload(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	if err = variation.Reload(tx); err != nil {
		t.Error(err)
	}
}

func testVariationsReloadAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	slice := VariationSlice{variation}

	if err = slice.ReloadAll(tx); err != nil {
		t.Error(err)
	}
}
func testVariationsSelect(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	slice, err := Variations(tx).All()
	if err != nil {
		t.Error(err)
	}

	if len(slice) != 1 {
		t.Error("want one record, got:", len(slice))
	}
}

var (
	variationDBTypes = map[string]string{`AuthorID`: `bigint`, `CopyrightID`: `bigint`, `CreatedAt`: `datetime`, `DeletedAt`: `datetime`, `EwSongID`: `bigint`, `ID`: `bigint`, `JyvaskylaSongID`: `bigint`, `LanguageID`: `bigint`, `SongID`: `bigint`, `UpdatedAt`: `datetime`, `VariationID`: `bigint`}
	_                = bytes.MinRead
)

func testVariationsUpdate(t *testing.T) {
	t.Parallel()

	if len(variationColumns) == len(variationPrimaryKeyColumns) {
		t.Skip("Skipping table with only primary key columns")
	}

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	count, err := Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}

	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err = variation.Update(tx); err != nil {
		t.Error(err)
	}
}

func testVariationsSliceUpdateAll(t *testing.T) {
	t.Parallel()

	if len(variationColumns) == len(variationPrimaryKeyColumns) {
		t.Skip("Skipping table with only primary key columns")
	}

	seed := randomize.NewSeed()
	var err error
	variation := &Variation{}
	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Insert(tx); err != nil {
		t.Error(err)
	}

	count, err := Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}

	if err = randomize.Struct(seed, variation, variationDBTypes, true, variationPrimaryKeyColumns...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	// Remove Primary keys and unique columns from what we plan to update
	var fields []string
	if strmangle.StringSliceMatch(variationColumns, variationPrimaryKeyColumns) {
		fields = variationColumns
	} else {
		fields = strmangle.SetComplement(
			variationColumns,
			variationPrimaryKeyColumns,
		)
	}

	value := reflect.Indirect(reflect.ValueOf(variation))
	updateMap := M{}
	for _, col := range fields {
		updateMap[col] = value.FieldByName(strmangle.TitleCase(col)).Interface()
	}

	slice := VariationSlice{variation}
	if err = slice.UpdateAll(tx, updateMap); err != nil {
		t.Error(err)
	}
}
func testVariationsUpsert(t *testing.T) {
	t.Parallel()

	if len(variationColumns) == len(variationPrimaryKeyColumns) {
		t.Skip("Skipping table with only primary key columns")
	}

	seed := randomize.NewSeed()
	var err error
	// Attempt the INSERT side of an UPSERT
	variation := Variation{}
	if err = randomize.Struct(seed, &variation, variationDBTypes, true); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variation.Upsert(tx, nil); err != nil {
		t.Errorf("Unable to upsert Variation: %s", err)
	}

	count, err := Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}
	if count != 1 {
		t.Error("want one record, got:", count)
	}

	// Attempt the UPDATE side of an UPSERT
	if err = randomize.Struct(seed, &variation, variationDBTypes, false, variationPrimaryKeyColumns...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err = variation.Upsert(tx, nil); err != nil {
		t.Errorf("Unable to upsert Variation: %s", err)
	}

	count, err = Variations(tx).Count()
	if err != nil {
		t.Error(err)
	}
	if count != 1 {
		t.Error("want one record, got:", count)
	}
}
