// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"bytes"
	"reflect"
	"testing"

	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/randomize"
	"github.com/volatiletech/sqlboiler/strmangle"
)

func testVariationVersions(t *testing.T) {
	t.Parallel()

	query := VariationVersions(nil)

	if query.Query == nil {
		t.Error("expected a query, got nothing")
	}
}
func testVariationVersionsDelete(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	if err = variationVersion.Delete(tx); err != nil {
		t.Error(err)
	}

	count, err := VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 0 {
		t.Error("want zero records, got:", count)
	}
}

func testVariationVersionsQueryDeleteAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	if err = VariationVersions(tx).DeleteAll(); err != nil {
		t.Error(err)
	}

	count, err := VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 0 {
		t.Error("want zero records, got:", count)
	}
}

func testVariationVersionsSliceDeleteAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	slice := VariationVersionSlice{variationVersion}

	if err = slice.DeleteAll(tx); err != nil {
		t.Error(err)
	}

	count, err := VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 0 {
		t.Error("want zero records, got:", count)
	}
}
func testVariationVersionsExists(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	e, err := VariationVersionExists(tx, variationVersion.ID)
	if err != nil {
		t.Errorf("Unable to check if VariationVersion exists: %s", err)
	}
	if !e {
		t.Errorf("Expected VariationVersionExistsG to return true, but got false.")
	}
}
func testVariationVersionsFind(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	variationVersionFound, err := FindVariationVersion(tx, variationVersion.ID)
	if err != nil {
		t.Error(err)
	}

	if variationVersionFound == nil {
		t.Error("want a record, got nil")
	}
}
func testVariationVersionsBind(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	if err = VariationVersions(tx).Bind(variationVersion); err != nil {
		t.Error(err)
	}
}

func testVariationVersionsOne(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	if x, err := VariationVersions(tx).One(); err != nil {
		t.Error(err)
	} else if x == nil {
		t.Error("expected to get a non nil record")
	}
}

func testVariationVersionsAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersionOne := &VariationVersion{}
	variationVersionTwo := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersionOne, variationVersionDBTypes, false, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}
	if err = randomize.Struct(seed, variationVersionTwo, variationVersionDBTypes, false, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersionOne.Insert(tx); err != nil {
		t.Error(err)
	}
	if err = variationVersionTwo.Insert(tx); err != nil {
		t.Error(err)
	}

	slice, err := VariationVersions(tx).All()
	if err != nil {
		t.Error(err)
	}

	if len(slice) != 2 {
		t.Error("want 2 records, got:", len(slice))
	}
}

func testVariationVersionsCount(t *testing.T) {
	t.Parallel()

	var err error
	seed := randomize.NewSeed()
	variationVersionOne := &VariationVersion{}
	variationVersionTwo := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersionOne, variationVersionDBTypes, false, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}
	if err = randomize.Struct(seed, variationVersionTwo, variationVersionDBTypes, false, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersionOne.Insert(tx); err != nil {
		t.Error(err)
	}
	if err = variationVersionTwo.Insert(tx); err != nil {
		t.Error(err)
	}

	count, err := VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 2 {
		t.Error("want 2 records, got:", count)
	}
}
func variationVersionBeforeInsertHook(e boil.Executor, o *VariationVersion) error {
	*o = VariationVersion{}
	return nil
}

func variationVersionAfterInsertHook(e boil.Executor, o *VariationVersion) error {
	*o = VariationVersion{}
	return nil
}

func variationVersionAfterSelectHook(e boil.Executor, o *VariationVersion) error {
	*o = VariationVersion{}
	return nil
}

func variationVersionBeforeUpdateHook(e boil.Executor, o *VariationVersion) error {
	*o = VariationVersion{}
	return nil
}

func variationVersionAfterUpdateHook(e boil.Executor, o *VariationVersion) error {
	*o = VariationVersion{}
	return nil
}

func variationVersionBeforeDeleteHook(e boil.Executor, o *VariationVersion) error {
	*o = VariationVersion{}
	return nil
}

func variationVersionAfterDeleteHook(e boil.Executor, o *VariationVersion) error {
	*o = VariationVersion{}
	return nil
}

func variationVersionBeforeUpsertHook(e boil.Executor, o *VariationVersion) error {
	*o = VariationVersion{}
	return nil
}

func variationVersionAfterUpsertHook(e boil.Executor, o *VariationVersion) error {
	*o = VariationVersion{}
	return nil
}

func testVariationVersionsHooks(t *testing.T) {
	t.Parallel()

	var err error

	empty := &VariationVersion{}
	o := &VariationVersion{}

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, o, variationVersionDBTypes, false); err != nil {
		t.Errorf("Unable to randomize VariationVersion object: %s", err)
	}

	AddVariationVersionHook(boil.BeforeInsertHook, variationVersionBeforeInsertHook)
	if err = o.doBeforeInsertHooks(nil); err != nil {
		t.Errorf("Unable to execute doBeforeInsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeInsertHook function to empty object, but got: %#v", o)
	}
	variationVersionBeforeInsertHooks = []VariationVersionHook{}

	AddVariationVersionHook(boil.AfterInsertHook, variationVersionAfterInsertHook)
	if err = o.doAfterInsertHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterInsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterInsertHook function to empty object, but got: %#v", o)
	}
	variationVersionAfterInsertHooks = []VariationVersionHook{}

	AddVariationVersionHook(boil.AfterSelectHook, variationVersionAfterSelectHook)
	if err = o.doAfterSelectHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterSelectHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterSelectHook function to empty object, but got: %#v", o)
	}
	variationVersionAfterSelectHooks = []VariationVersionHook{}

	AddVariationVersionHook(boil.BeforeUpdateHook, variationVersionBeforeUpdateHook)
	if err = o.doBeforeUpdateHooks(nil); err != nil {
		t.Errorf("Unable to execute doBeforeUpdateHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeUpdateHook function to empty object, but got: %#v", o)
	}
	variationVersionBeforeUpdateHooks = []VariationVersionHook{}

	AddVariationVersionHook(boil.AfterUpdateHook, variationVersionAfterUpdateHook)
	if err = o.doAfterUpdateHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterUpdateHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterUpdateHook function to empty object, but got: %#v", o)
	}
	variationVersionAfterUpdateHooks = []VariationVersionHook{}

	AddVariationVersionHook(boil.BeforeDeleteHook, variationVersionBeforeDeleteHook)
	if err = o.doBeforeDeleteHooks(nil); err != nil {
		t.Errorf("Unable to execute doBeforeDeleteHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeDeleteHook function to empty object, but got: %#v", o)
	}
	variationVersionBeforeDeleteHooks = []VariationVersionHook{}

	AddVariationVersionHook(boil.AfterDeleteHook, variationVersionAfterDeleteHook)
	if err = o.doAfterDeleteHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterDeleteHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterDeleteHook function to empty object, but got: %#v", o)
	}
	variationVersionAfterDeleteHooks = []VariationVersionHook{}

	AddVariationVersionHook(boil.BeforeUpsertHook, variationVersionBeforeUpsertHook)
	if err = o.doBeforeUpsertHooks(nil); err != nil {
		t.Errorf("Unable to execute doBeforeUpsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected BeforeUpsertHook function to empty object, but got: %#v", o)
	}
	variationVersionBeforeUpsertHooks = []VariationVersionHook{}

	AddVariationVersionHook(boil.AfterUpsertHook, variationVersionAfterUpsertHook)
	if err = o.doAfterUpsertHooks(nil); err != nil {
		t.Errorf("Unable to execute doAfterUpsertHooks: %s", err)
	}
	if !reflect.DeepEqual(o, empty) {
		t.Errorf("Expected AfterUpsertHook function to empty object, but got: %#v", o)
	}
	variationVersionAfterUpsertHooks = []VariationVersionHook{}
}
func testVariationVersionsInsert(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	count, err := VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}
}

func testVariationVersionsInsertWhitelist(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx, variationVersionColumnsWithoutDefault...); err != nil {
		t.Error(err)
	}

	count, err := VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}
}

func testVariationVersionToManySourceVariationVersionBranches(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c Branch

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, branchDBTypes, false, branchColumnsWithDefault...)
	randomize.Struct(seed, &c, branchDBTypes, false, branchColumnsWithDefault...)

	b.SourceVariationVersionID = a.ID
	c.SourceVariationVersionID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	branch, err := a.SourceVariationVersionBranches(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range branch {
		if v.SourceVariationVersionID == b.SourceVariationVersionID {
			bFound = true
		}
		if v.SourceVariationVersionID == c.SourceVariationVersionID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationVersionSlice{&a}
	if err = a.L.LoadSourceVariationVersionBranches(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SourceVariationVersionBranches); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SourceVariationVersionBranches = nil
	if err = a.L.LoadSourceVariationVersionBranches(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SourceVariationVersionBranches); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", branch)
	}
}

func testVariationVersionToManyDestinationVariationVersionBranches(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c Branch

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, branchDBTypes, false, branchColumnsWithDefault...)
	randomize.Struct(seed, &c, branchDBTypes, false, branchColumnsWithDefault...)

	b.DestinationVariationVersionID = a.ID
	c.DestinationVariationVersionID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	branch, err := a.DestinationVariationVersionBranches(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range branch {
		if v.DestinationVariationVersionID == b.DestinationVariationVersionID {
			bFound = true
		}
		if v.DestinationVariationVersionID == c.DestinationVariationVersionID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationVersionSlice{&a}
	if err = a.L.LoadDestinationVariationVersionBranches(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DestinationVariationVersionBranches); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.DestinationVariationVersionBranches = nil
	if err = a.L.LoadDestinationVariationVersionBranches(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DestinationVariationVersionBranches); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", branch)
	}
}

func testVariationVersionToManyVariationVersion1Merges(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c Merge

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, mergeDBTypes, false, mergeColumnsWithDefault...)
	randomize.Struct(seed, &c, mergeDBTypes, false, mergeColumnsWithDefault...)

	b.VariationVersion1ID = a.ID
	c.VariationVersion1ID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	merge, err := a.VariationVersion1Merges(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range merge {
		if v.VariationVersion1ID == b.VariationVersion1ID {
			bFound = true
		}
		if v.VariationVersion1ID == c.VariationVersion1ID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationVersionSlice{&a}
	if err = a.L.LoadVariationVersion1Merges(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.VariationVersion1Merges); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.VariationVersion1Merges = nil
	if err = a.L.LoadVariationVersion1Merges(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.VariationVersion1Merges); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", merge)
	}
}

func testVariationVersionToManyVariationVersion2Merges(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c Merge

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, mergeDBTypes, false, mergeColumnsWithDefault...)
	randomize.Struct(seed, &c, mergeDBTypes, false, mergeColumnsWithDefault...)

	b.VariationVersion2ID = a.ID
	c.VariationVersion2ID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	merge, err := a.VariationVersion2Merges(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range merge {
		if v.VariationVersion2ID == b.VariationVersion2ID {
			bFound = true
		}
		if v.VariationVersion2ID == c.VariationVersion2ID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationVersionSlice{&a}
	if err = a.L.LoadVariationVersion2Merges(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.VariationVersion2Merges); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.VariationVersion2Merges = nil
	if err = a.L.LoadVariationVersion2Merges(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.VariationVersion2Merges); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", merge)
	}
}

func testVariationVersionToManyDestinationVariationVersionMerges(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c Merge

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, mergeDBTypes, false, mergeColumnsWithDefault...)
	randomize.Struct(seed, &c, mergeDBTypes, false, mergeColumnsWithDefault...)

	b.DestinationVariationVersionID = a.ID
	c.DestinationVariationVersionID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	merge, err := a.DestinationVariationVersionMerges(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range merge {
		if v.DestinationVariationVersionID == b.DestinationVariationVersionID {
			bFound = true
		}
		if v.DestinationVariationVersionID == c.DestinationVariationVersionID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationVersionSlice{&a}
	if err = a.L.LoadDestinationVariationVersionMerges(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DestinationVariationVersionMerges); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.DestinationVariationVersionMerges = nil
	if err = a.L.LoadDestinationVariationVersionMerges(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.DestinationVariationVersionMerges); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", merge)
	}
}

func testVariationVersionToManySREwConflicts(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c SREwConflict

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, srEwConflictDBTypes, false, srEwConflictColumnsWithDefault...)
	randomize.Struct(seed, &c, srEwConflictDBTypes, false, srEwConflictColumnsWithDefault...)

	b.VariationVersionID = a.ID
	c.VariationVersionID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	srEwConflict, err := a.SREwConflicts(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range srEwConflict {
		if v.VariationVersionID == b.VariationVersionID {
			bFound = true
		}
		if v.VariationVersionID == c.VariationVersionID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationVersionSlice{&a}
	if err = a.L.LoadSREwConflicts(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SREwConflicts); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SREwConflicts = nil
	if err = a.L.LoadSREwConflicts(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SREwConflicts); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", srEwConflict)
	}
}

func testVariationVersionToManySREwSongs(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c SREwSong

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, srEwSongDBTypes, false, srEwSongColumnsWithDefault...)
	randomize.Struct(seed, &c, srEwSongDBTypes, false, srEwSongColumnsWithDefault...)

	b.VariationVersionID = a.ID
	c.VariationVersionID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	srEwSong, err := a.SREwSongs(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range srEwSong {
		if v.VariationVersionID == b.VariationVersionID {
			bFound = true
		}
		if v.VariationVersionID == c.VariationVersionID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationVersionSlice{&a}
	if err = a.L.LoadSREwSongs(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SREwSongs); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SREwSongs = nil
	if err = a.L.LoadSREwSongs(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SREwSongs); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", srEwSong)
	}
}

func testVariationVersionToManySRNewVariationVersions(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c SRNewVariationVersion

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, srNewVariationVersionDBTypes, false, srNewVariationVersionColumnsWithDefault...)
	randomize.Struct(seed, &c, srNewVariationVersionDBTypes, false, srNewVariationVersionColumnsWithDefault...)

	b.VariationVersionID = a.ID
	c.VariationVersionID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	srNewVariationVersion, err := a.SRNewVariationVersions(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range srNewVariationVersion {
		if v.VariationVersionID == b.VariationVersionID {
			bFound = true
		}
		if v.VariationVersionID == c.VariationVersionID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationVersionSlice{&a}
	if err = a.L.LoadSRNewVariationVersions(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRNewVariationVersions); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SRNewVariationVersions = nil
	if err = a.L.LoadSRNewVariationVersions(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRNewVariationVersions); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", srNewVariationVersion)
	}
}

func testVariationVersionToManySRPassivatedVariationVersions(t *testing.T) {
	var err error
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c SRPassivatedVariationVersion

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}

	randomize.Struct(seed, &b, srPassivatedVariationVersionDBTypes, false, srPassivatedVariationVersionColumnsWithDefault...)
	randomize.Struct(seed, &c, srPassivatedVariationVersionDBTypes, false, srPassivatedVariationVersionColumnsWithDefault...)

	b.VariationVersionID = a.ID
	c.VariationVersionID = a.ID
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	srPassivatedVariationVersion, err := a.SRPassivatedVariationVersions(tx).All()
	if err != nil {
		t.Fatal(err)
	}

	bFound, cFound := false, false
	for _, v := range srPassivatedVariationVersion {
		if v.VariationVersionID == b.VariationVersionID {
			bFound = true
		}
		if v.VariationVersionID == c.VariationVersionID {
			cFound = true
		}
	}

	if !bFound {
		t.Error("expected to find b")
	}
	if !cFound {
		t.Error("expected to find c")
	}

	slice := VariationVersionSlice{&a}
	if err = a.L.LoadSRPassivatedVariationVersions(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRPassivatedVariationVersions); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	a.R.SRPassivatedVariationVersions = nil
	if err = a.L.LoadSRPassivatedVariationVersions(tx, true, &a); err != nil {
		t.Fatal(err)
	}
	if got := len(a.R.SRPassivatedVariationVersions); got != 2 {
		t.Error("number of eager loaded records wrong, got:", got)
	}

	if t.Failed() {
		t.Logf("%#v", srPassivatedVariationVersion)
	}
}

func testVariationVersionToManyAddOpSourceVariationVersionBranches(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c, d, e Branch

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Branch{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, branchDBTypes, false, strmangle.SetComplement(branchPrimaryKeyColumns, branchColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*Branch{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSourceVariationVersionBranches(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.SourceVariationVersionID {
			t.Error("foreign key was wrong value", a.ID, first.SourceVariationVersionID)
		}
		if a.ID != second.SourceVariationVersionID {
			t.Error("foreign key was wrong value", a.ID, second.SourceVariationVersionID)
		}

		if first.R.SourceVariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.SourceVariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SourceVariationVersionBranches[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SourceVariationVersionBranches[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SourceVariationVersionBranches(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationVersionToManyAddOpDestinationVariationVersionBranches(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c, d, e Branch

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Branch{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, branchDBTypes, false, strmangle.SetComplement(branchPrimaryKeyColumns, branchColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*Branch{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddDestinationVariationVersionBranches(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.DestinationVariationVersionID {
			t.Error("foreign key was wrong value", a.ID, first.DestinationVariationVersionID)
		}
		if a.ID != second.DestinationVariationVersionID {
			t.Error("foreign key was wrong value", a.ID, second.DestinationVariationVersionID)
		}

		if first.R.DestinationVariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.DestinationVariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.DestinationVariationVersionBranches[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.DestinationVariationVersionBranches[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.DestinationVariationVersionBranches(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationVersionToManyAddOpVariationVersion1Merges(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c, d, e Merge

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Merge{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, mergeDBTypes, false, strmangle.SetComplement(mergePrimaryKeyColumns, mergeColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*Merge{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddVariationVersion1Merges(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationVersion1ID {
			t.Error("foreign key was wrong value", a.ID, first.VariationVersion1ID)
		}
		if a.ID != second.VariationVersion1ID {
			t.Error("foreign key was wrong value", a.ID, second.VariationVersion1ID)
		}

		if first.R.VariationVersion1 != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.VariationVersion1 != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.VariationVersion1Merges[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.VariationVersion1Merges[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.VariationVersion1Merges(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationVersionToManyAddOpVariationVersion2Merges(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c, d, e Merge

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Merge{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, mergeDBTypes, false, strmangle.SetComplement(mergePrimaryKeyColumns, mergeColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*Merge{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddVariationVersion2Merges(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationVersion2ID {
			t.Error("foreign key was wrong value", a.ID, first.VariationVersion2ID)
		}
		if a.ID != second.VariationVersion2ID {
			t.Error("foreign key was wrong value", a.ID, second.VariationVersion2ID)
		}

		if first.R.VariationVersion2 != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.VariationVersion2 != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.VariationVersion2Merges[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.VariationVersion2Merges[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.VariationVersion2Merges(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationVersionToManyAddOpDestinationVariationVersionMerges(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c, d, e Merge

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*Merge{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, mergeDBTypes, false, strmangle.SetComplement(mergePrimaryKeyColumns, mergeColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*Merge{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddDestinationVariationVersionMerges(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.DestinationVariationVersionID {
			t.Error("foreign key was wrong value", a.ID, first.DestinationVariationVersionID)
		}
		if a.ID != second.DestinationVariationVersionID {
			t.Error("foreign key was wrong value", a.ID, second.DestinationVariationVersionID)
		}

		if first.R.DestinationVariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.DestinationVariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.DestinationVariationVersionMerges[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.DestinationVariationVersionMerges[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.DestinationVariationVersionMerges(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationVersionToManyAddOpSREwConflicts(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c, d, e SREwConflict

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SREwConflict{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, srEwConflictDBTypes, false, strmangle.SetComplement(srEwConflictPrimaryKeyColumns, srEwConflictColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SREwConflict{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSREwConflicts(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationVersionID {
			t.Error("foreign key was wrong value", a.ID, first.VariationVersionID)
		}
		if a.ID != second.VariationVersionID {
			t.Error("foreign key was wrong value", a.ID, second.VariationVersionID)
		}

		if first.R.VariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.VariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SREwConflicts[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SREwConflicts[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SREwConflicts(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationVersionToManyAddOpSREwSongs(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c, d, e SREwSong

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SREwSong{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, srEwSongDBTypes, false, strmangle.SetComplement(srEwSongPrimaryKeyColumns, srEwSongColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SREwSong{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSREwSongs(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationVersionID {
			t.Error("foreign key was wrong value", a.ID, first.VariationVersionID)
		}
		if a.ID != second.VariationVersionID {
			t.Error("foreign key was wrong value", a.ID, second.VariationVersionID)
		}

		if first.R.VariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.VariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SREwSongs[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SREwSongs[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SREwSongs(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationVersionToManyAddOpSRNewVariationVersions(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c, d, e SRNewVariationVersion

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SRNewVariationVersion{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, srNewVariationVersionDBTypes, false, strmangle.SetComplement(srNewVariationVersionPrimaryKeyColumns, srNewVariationVersionColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SRNewVariationVersion{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSRNewVariationVersions(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationVersionID {
			t.Error("foreign key was wrong value", a.ID, first.VariationVersionID)
		}
		if a.ID != second.VariationVersionID {
			t.Error("foreign key was wrong value", a.ID, second.VariationVersionID)
		}

		if first.R.VariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.VariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SRNewVariationVersions[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SRNewVariationVersions[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SRNewVariationVersions(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationVersionToManyAddOpSRPassivatedVariationVersions(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c, d, e SRPassivatedVariationVersion

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	foreigners := []*SRPassivatedVariationVersion{&b, &c, &d, &e}
	for _, x := range foreigners {
		if err = randomize.Struct(seed, x, srPassivatedVariationVersionDBTypes, false, strmangle.SetComplement(srPassivatedVariationVersionPrimaryKeyColumns, srPassivatedVariationVersionColumnsWithoutDefault)...); err != nil {
			t.Fatal(err)
		}
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = c.Insert(tx); err != nil {
		t.Fatal(err)
	}

	foreignersSplitByInsertion := [][]*SRPassivatedVariationVersion{
		{&b, &c},
		{&d, &e},
	}

	for i, x := range foreignersSplitByInsertion {
		err = a.AddSRPassivatedVariationVersions(tx, i != 0, x...)
		if err != nil {
			t.Fatal(err)
		}

		first := x[0]
		second := x[1]

		if a.ID != first.VariationVersionID {
			t.Error("foreign key was wrong value", a.ID, first.VariationVersionID)
		}
		if a.ID != second.VariationVersionID {
			t.Error("foreign key was wrong value", a.ID, second.VariationVersionID)
		}

		if first.R.VariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}
		if second.R.VariationVersion != &a {
			t.Error("relationship was not added properly to the foreign slice")
		}

		if a.R.SRPassivatedVariationVersions[i*2] != first {
			t.Error("relationship struct slice not set to correct value")
		}
		if a.R.SRPassivatedVariationVersions[i*2+1] != second {
			t.Error("relationship struct slice not set to correct value")
		}

		count, err := a.SRPassivatedVariationVersions(tx).Count()
		if err != nil {
			t.Fatal(err)
		}
		if want := int64((i + 1) * 2); count != want {
			t.Error("want", want, "got", count)
		}
	}
}
func testVariationVersionToOneVariationUsingVariation(t *testing.T) {
	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var local VariationVersion
	var foreign Variation

	seed := randomize.NewSeed()
	if err := randomize.Struct(seed, &local, variationVersionDBTypes, false, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}
	if err := randomize.Struct(seed, &foreign, variationDBTypes, false, variationColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize Variation struct: %s", err)
	}

	if err := foreign.Insert(tx); err != nil {
		t.Fatal(err)
	}

	local.VariationID = foreign.ID
	if err := local.Insert(tx); err != nil {
		t.Fatal(err)
	}

	check, err := local.Variation(tx).One()
	if err != nil {
		t.Fatal(err)
	}

	if check.ID != foreign.ID {
		t.Errorf("want: %v, got %v", foreign.ID, check.ID)
	}

	slice := VariationVersionSlice{&local}
	if err = local.L.LoadVariation(tx, false, (*[]*VariationVersion)(&slice)); err != nil {
		t.Fatal(err)
	}
	if local.R.Variation == nil {
		t.Error("struct should have been eager loaded")
	}

	local.R.Variation = nil
	if err = local.L.LoadVariation(tx, true, &local); err != nil {
		t.Fatal(err)
	}
	if local.R.Variation == nil {
		t.Error("struct should have been eager loaded")
	}
}

func testVariationVersionToOneSetOpVariationUsingVariation(t *testing.T) {
	var err error

	tx := MustTx(boil.Begin())
	defer tx.Rollback()

	var a VariationVersion
	var b, c Variation

	seed := randomize.NewSeed()
	if err = randomize.Struct(seed, &a, variationVersionDBTypes, false, strmangle.SetComplement(variationVersionPrimaryKeyColumns, variationVersionColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &b, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}
	if err = randomize.Struct(seed, &c, variationDBTypes, false, strmangle.SetComplement(variationPrimaryKeyColumns, variationColumnsWithoutDefault)...); err != nil {
		t.Fatal(err)
	}

	if err := a.Insert(tx); err != nil {
		t.Fatal(err)
	}
	if err = b.Insert(tx); err != nil {
		t.Fatal(err)
	}

	for i, x := range []*Variation{&b, &c} {
		err = a.SetVariation(tx, i != 0, x)
		if err != nil {
			t.Fatal(err)
		}

		if a.R.Variation != x {
			t.Error("relationship struct not set to correct value")
		}

		if x.R.VariationVersions[0] != &a {
			t.Error("failed to append to foreign relationship struct")
		}
		if a.VariationID != x.ID {
			t.Error("foreign key was wrong value", a.VariationID)
		}

		zero := reflect.Zero(reflect.TypeOf(a.VariationID))
		reflect.Indirect(reflect.ValueOf(&a.VariationID)).Set(zero)

		if err = a.Reload(tx); err != nil {
			t.Fatal("failed to reload", err)
		}

		if a.VariationID != x.ID {
			t.Error("foreign key was wrong value", a.VariationID, x.ID)
		}
	}
}
func testVariationVersionsReload(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	if err = variationVersion.Reload(tx); err != nil {
		t.Error(err)
	}
}

func testVariationVersionsReloadAll(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	slice := VariationVersionSlice{variationVersion}

	if err = slice.ReloadAll(tx); err != nil {
		t.Error(err)
	}
}
func testVariationVersionsSelect(t *testing.T) {
	t.Parallel()

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	slice, err := VariationVersions(tx).All()
	if err != nil {
		t.Error(err)
	}

	if len(slice) != 1 {
		t.Error("want one record, got:", len(slice))
	}
}

var (
	variationVersionDBTypes = map[string]string{`CreatedAt`: `datetime`, `DisabledAt`: `datetime`, `ID`: `bigint`, `Name`: `varchar`, `Newest`: `tinyint`, `Text`: `text`, `VariationID`: `bigint`, `Version`: `int`}
	_                       = bytes.MinRead
)

func testVariationVersionsUpdate(t *testing.T) {
	t.Parallel()

	if len(variationVersionColumns) == len(variationVersionPrimaryKeyColumns) {
		t.Skip("Skipping table with only primary key columns")
	}

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	count, err := VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}

	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err = variationVersion.Update(tx); err != nil {
		t.Error(err)
	}
}

func testVariationVersionsSliceUpdateAll(t *testing.T) {
	t.Parallel()

	if len(variationVersionColumns) == len(variationVersionPrimaryKeyColumns) {
		t.Skip("Skipping table with only primary key columns")
	}

	seed := randomize.NewSeed()
	var err error
	variationVersion := &VariationVersion{}
	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionColumnsWithDefault...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Insert(tx); err != nil {
		t.Error(err)
	}

	count, err := VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}

	if count != 1 {
		t.Error("want one record, got:", count)
	}

	if err = randomize.Struct(seed, variationVersion, variationVersionDBTypes, true, variationVersionPrimaryKeyColumns...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	// Remove Primary keys and unique columns from what we plan to update
	var fields []string
	if strmangle.StringSliceMatch(variationVersionColumns, variationVersionPrimaryKeyColumns) {
		fields = variationVersionColumns
	} else {
		fields = strmangle.SetComplement(
			variationVersionColumns,
			variationVersionPrimaryKeyColumns,
		)
	}

	value := reflect.Indirect(reflect.ValueOf(variationVersion))
	updateMap := M{}
	for _, col := range fields {
		updateMap[col] = value.FieldByName(strmangle.TitleCase(col)).Interface()
	}

	slice := VariationVersionSlice{variationVersion}
	if err = slice.UpdateAll(tx, updateMap); err != nil {
		t.Error(err)
	}
}
func testVariationVersionsUpsert(t *testing.T) {
	t.Parallel()

	if len(variationVersionColumns) == len(variationVersionPrimaryKeyColumns) {
		t.Skip("Skipping table with only primary key columns")
	}

	seed := randomize.NewSeed()
	var err error
	// Attempt the INSERT side of an UPSERT
	variationVersion := VariationVersion{}
	if err = randomize.Struct(seed, &variationVersion, variationVersionDBTypes, true); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	tx := MustTx(boil.Begin())
	defer tx.Rollback()
	if err = variationVersion.Upsert(tx, nil); err != nil {
		t.Errorf("Unable to upsert VariationVersion: %s", err)
	}

	count, err := VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}
	if count != 1 {
		t.Error("want one record, got:", count)
	}

	// Attempt the UPDATE side of an UPSERT
	if err = randomize.Struct(seed, &variationVersion, variationVersionDBTypes, false, variationVersionPrimaryKeyColumns...); err != nil {
		t.Errorf("Unable to randomize VariationVersion struct: %s", err)
	}

	if err = variationVersion.Upsert(tx, nil); err != nil {
		t.Errorf("Unable to upsert VariationVersion: %s", err)
	}

	count, err = VariationVersions(tx).Count()
	if err != nil {
		t.Error(err)
	}
	if count != 1 {
		t.Error("want one record, got:", count)
	}
}
