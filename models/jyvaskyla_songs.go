// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"bytes"
	"database/sql"
	"fmt"
	"reflect"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/strmangle"
	"gopkg.in/volatiletech/null.v6"
)

// JyvaskylaSong is an object representing the database table.
type JyvaskylaSong struct {
	ID             uint64      `boil:"id" json:"id" toml:"id" yaml:"id"`
	AddedAt        null.Uint64 `boil:"added_at" json:"added_at,omitempty" toml:"added_at" yaml:"added_at,omitempty"`
	AddedBy        null.String `boil:"added_by" json:"added_by,omitempty" toml:"added_by" yaml:"added_by,omitempty"`
	AdditionalInfo null.String `boil:"additional_info" json:"additional_info,omitempty" toml:"additional_info" yaml:"additional_info,omitempty"`
	ArrangementBy  null.String `boil:"arrangement_by" json:"arrangement_by,omitempty" toml:"arrangement_by" yaml:"arrangement_by,omitempty"`
	ComposedBy     null.String `boil:"composed_by" json:"composed_by,omitempty" toml:"composed_by" yaml:"composed_by,omitempty"`
	Copyright      null.String `boil:"copyright" json:"copyright,omitempty" toml:"copyright" yaml:"copyright,omitempty"`
	Deleted        null.Int8   `boil:"deleted" json:"deleted,omitempty" toml:"deleted" yaml:"deleted,omitempty"`
	GlobalID       null.Uint64 `boil:"global_id" json:"global_id,omitempty" toml:"global_id" yaml:"global_id,omitempty"`
	LyricsBy       null.String `boil:"lyrics_by" json:"lyrics_by,omitempty" toml:"lyrics_by" yaml:"lyrics_by,omitempty"`
	Modified       null.Time   `boil:"modified" json:"modified,omitempty" toml:"modified" yaml:"modified,omitempty"`
	Name           null.String `boil:"name" json:"name,omitempty" toml:"name" yaml:"name,omitempty"`
	OrigName       null.String `boil:"orig_name" json:"orig_name,omitempty" toml:"orig_name" yaml:"orig_name,omitempty"`
	Song           null.String `boil:"song" json:"song,omitempty" toml:"song" yaml:"song,omitempty"`
	SongbookID     null.Uint64 `boil:"songbook_id" json:"songbook_id,omitempty" toml:"songbook_id" yaml:"songbook_id,omitempty"`
	TranslatedBy   null.String `boil:"translated_by" json:"translated_by,omitempty" toml:"translated_by" yaml:"translated_by,omitempty"`
	Year           null.String `boil:"year" json:"year,omitempty" toml:"year" yaml:"year,omitempty"`

	R *jyvaskylaSongR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L jyvaskylaSongL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var JyvaskylaSongColumns = struct {
	ID             string
	AddedAt        string
	AddedBy        string
	AdditionalInfo string
	ArrangementBy  string
	ComposedBy     string
	Copyright      string
	Deleted        string
	GlobalID       string
	LyricsBy       string
	Modified       string
	Name           string
	OrigName       string
	Song           string
	SongbookID     string
	TranslatedBy   string
	Year           string
}{
	ID:             "id",
	AddedAt:        "added_at",
	AddedBy:        "added_by",
	AdditionalInfo: "additional_info",
	ArrangementBy:  "arrangement_by",
	ComposedBy:     "composed_by",
	Copyright:      "copyright",
	Deleted:        "deleted",
	GlobalID:       "global_id",
	LyricsBy:       "lyrics_by",
	Modified:       "modified",
	Name:           "name",
	OrigName:       "orig_name",
	Song:           "song",
	SongbookID:     "songbook_id",
	TranslatedBy:   "translated_by",
	Year:           "year",
}

// jyvaskylaSongR is where relationships are stored.
type jyvaskylaSongR struct {
}

// jyvaskylaSongL is where Load methods for each relationship are stored.
type jyvaskylaSongL struct{}

var (
	jyvaskylaSongColumns               = []string{"id", "added_at", "added_by", "additional_info", "arrangement_by", "composed_by", "copyright", "deleted", "global_id", "lyrics_by", "modified", "name", "orig_name", "song", "songbook_id", "translated_by", "year"}
	jyvaskylaSongColumnsWithoutDefault = []string{"added_at", "added_by", "additional_info", "arrangement_by", "composed_by", "copyright", "deleted", "global_id", "lyrics_by", "modified", "name", "orig_name", "song", "songbook_id", "translated_by", "year"}
	jyvaskylaSongColumnsWithDefault    = []string{"id"}
	jyvaskylaSongPrimaryKeyColumns     = []string{"id"}
)

type (
	// JyvaskylaSongSlice is an alias for a slice of pointers to JyvaskylaSong.
	// This should generally be used opposed to []JyvaskylaSong.
	JyvaskylaSongSlice []*JyvaskylaSong
	// JyvaskylaSongHook is the signature for custom JyvaskylaSong hook methods
	JyvaskylaSongHook func(boil.Executor, *JyvaskylaSong) error

	jyvaskylaSongQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	jyvaskylaSongType                 = reflect.TypeOf(&JyvaskylaSong{})
	jyvaskylaSongMapping              = queries.MakeStructMapping(jyvaskylaSongType)
	jyvaskylaSongPrimaryKeyMapping, _ = queries.BindMapping(jyvaskylaSongType, jyvaskylaSongMapping, jyvaskylaSongPrimaryKeyColumns)
	jyvaskylaSongInsertCacheMut       sync.RWMutex
	jyvaskylaSongInsertCache          = make(map[string]insertCache)
	jyvaskylaSongUpdateCacheMut       sync.RWMutex
	jyvaskylaSongUpdateCache          = make(map[string]updateCache)
	jyvaskylaSongUpsertCacheMut       sync.RWMutex
	jyvaskylaSongUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force bytes in case of primary key column that uses []byte (for relationship compares)
	_ = bytes.MinRead
)
var jyvaskylaSongBeforeInsertHooks []JyvaskylaSongHook
var jyvaskylaSongBeforeUpdateHooks []JyvaskylaSongHook
var jyvaskylaSongBeforeDeleteHooks []JyvaskylaSongHook
var jyvaskylaSongBeforeUpsertHooks []JyvaskylaSongHook

var jyvaskylaSongAfterInsertHooks []JyvaskylaSongHook
var jyvaskylaSongAfterSelectHooks []JyvaskylaSongHook
var jyvaskylaSongAfterUpdateHooks []JyvaskylaSongHook
var jyvaskylaSongAfterDeleteHooks []JyvaskylaSongHook
var jyvaskylaSongAfterUpsertHooks []JyvaskylaSongHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *JyvaskylaSong) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range jyvaskylaSongBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *JyvaskylaSong) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range jyvaskylaSongBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *JyvaskylaSong) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range jyvaskylaSongBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *JyvaskylaSong) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range jyvaskylaSongBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *JyvaskylaSong) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range jyvaskylaSongAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *JyvaskylaSong) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range jyvaskylaSongAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *JyvaskylaSong) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range jyvaskylaSongAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *JyvaskylaSong) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range jyvaskylaSongAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *JyvaskylaSong) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range jyvaskylaSongAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddJyvaskylaSongHook registers your hook function for all future operations.
func AddJyvaskylaSongHook(hookPoint boil.HookPoint, jyvaskylaSongHook JyvaskylaSongHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		jyvaskylaSongBeforeInsertHooks = append(jyvaskylaSongBeforeInsertHooks, jyvaskylaSongHook)
	case boil.BeforeUpdateHook:
		jyvaskylaSongBeforeUpdateHooks = append(jyvaskylaSongBeforeUpdateHooks, jyvaskylaSongHook)
	case boil.BeforeDeleteHook:
		jyvaskylaSongBeforeDeleteHooks = append(jyvaskylaSongBeforeDeleteHooks, jyvaskylaSongHook)
	case boil.BeforeUpsertHook:
		jyvaskylaSongBeforeUpsertHooks = append(jyvaskylaSongBeforeUpsertHooks, jyvaskylaSongHook)
	case boil.AfterInsertHook:
		jyvaskylaSongAfterInsertHooks = append(jyvaskylaSongAfterInsertHooks, jyvaskylaSongHook)
	case boil.AfterSelectHook:
		jyvaskylaSongAfterSelectHooks = append(jyvaskylaSongAfterSelectHooks, jyvaskylaSongHook)
	case boil.AfterUpdateHook:
		jyvaskylaSongAfterUpdateHooks = append(jyvaskylaSongAfterUpdateHooks, jyvaskylaSongHook)
	case boil.AfterDeleteHook:
		jyvaskylaSongAfterDeleteHooks = append(jyvaskylaSongAfterDeleteHooks, jyvaskylaSongHook)
	case boil.AfterUpsertHook:
		jyvaskylaSongAfterUpsertHooks = append(jyvaskylaSongAfterUpsertHooks, jyvaskylaSongHook)
	}
}

// OneP returns a single jyvaskylaSong record from the query, and panics on error.
func (q jyvaskylaSongQuery) OneP() *JyvaskylaSong {
	o, err := q.One()
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// One returns a single jyvaskylaSong record from the query.
func (q jyvaskylaSongQuery) One() (*JyvaskylaSong, error) {
	o := &JyvaskylaSong{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for jyvaskyla_songs")
	}

	if err := o.doAfterSelectHooks(queries.GetExecutor(q.Query)); err != nil {
		return o, err
	}

	return o, nil
}

// AllP returns all JyvaskylaSong records from the query, and panics on error.
func (q jyvaskylaSongQuery) AllP() JyvaskylaSongSlice {
	o, err := q.All()
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// All returns all JyvaskylaSong records from the query.
func (q jyvaskylaSongQuery) All() (JyvaskylaSongSlice, error) {
	var o []*JyvaskylaSong

	err := q.Bind(&o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to JyvaskylaSong slice")
	}

	if len(jyvaskylaSongAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(queries.GetExecutor(q.Query)); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountP returns the count of all JyvaskylaSong records in the query, and panics on error.
func (q jyvaskylaSongQuery) CountP() int64 {
	c, err := q.Count()
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// Count returns the count of all JyvaskylaSong records in the query.
func (q jyvaskylaSongQuery) Count() (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow().Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count jyvaskyla_songs rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table, and panics on error.
func (q jyvaskylaSongQuery) ExistsP() bool {
	e, err := q.Exists()
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// Exists checks if the row exists in the table.
func (q jyvaskylaSongQuery) Exists() (bool, error) {
	var count int64

	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow().Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if jyvaskyla_songs exists")
	}

	return count > 0, nil
}

// JyvaskylaSongsG retrieves all records.
func JyvaskylaSongsG(mods ...qm.QueryMod) jyvaskylaSongQuery {
	return JyvaskylaSongs(boil.GetDB(), mods...)
}

// JyvaskylaSongs retrieves all the records using an executor.
func JyvaskylaSongs(exec boil.Executor, mods ...qm.QueryMod) jyvaskylaSongQuery {
	mods = append(mods, qm.From("`jyvaskyla_songs`"))
	return jyvaskylaSongQuery{NewQuery(exec, mods...)}
}

// FindJyvaskylaSongG retrieves a single record by ID.
func FindJyvaskylaSongG(id uint64, selectCols ...string) (*JyvaskylaSong, error) {
	return FindJyvaskylaSong(boil.GetDB(), id, selectCols...)
}

// FindJyvaskylaSongGP retrieves a single record by ID, and panics on error.
func FindJyvaskylaSongGP(id uint64, selectCols ...string) *JyvaskylaSong {
	retobj, err := FindJyvaskylaSong(boil.GetDB(), id, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindJyvaskylaSong retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindJyvaskylaSong(exec boil.Executor, id uint64, selectCols ...string) (*JyvaskylaSong, error) {
	jyvaskylaSongObj := &JyvaskylaSong{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `jyvaskyla_songs` where `id`=?", sel,
	)

	q := queries.Raw(exec, query, id)

	err := q.Bind(jyvaskylaSongObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from jyvaskyla_songs")
	}

	return jyvaskylaSongObj, nil
}

// FindJyvaskylaSongP retrieves a single record by ID with an executor, and panics on error.
func FindJyvaskylaSongP(exec boil.Executor, id uint64, selectCols ...string) *JyvaskylaSong {
	retobj, err := FindJyvaskylaSong(exec, id, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *JyvaskylaSong) InsertG(whitelist ...string) error {
	return o.Insert(boil.GetDB(), whitelist...)
}

// InsertGP a single record, and panics on error. See Insert for whitelist
// behavior description.
func (o *JyvaskylaSong) InsertGP(whitelist ...string) {
	if err := o.Insert(boil.GetDB(), whitelist...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// InsertP a single record using an executor, and panics on error. See Insert
// for whitelist behavior description.
func (o *JyvaskylaSong) InsertP(exec boil.Executor, whitelist ...string) {
	if err := o.Insert(exec, whitelist...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Insert a single record using an executor.
// Whitelist behavior: If a whitelist is provided, only those columns supplied are inserted
// No whitelist behavior: Without a whitelist, columns are inferred by the following rules:
// - All columns without a default value are included (i.e. name, age)
// - All columns with a default, but non-zero are included (i.e. health = 75)
func (o *JyvaskylaSong) Insert(exec boil.Executor, whitelist ...string) error {
	if o == nil {
		return errors.New("models: no jyvaskyla_songs provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(jyvaskylaSongColumnsWithDefault, o)

	key := makeCacheKey(whitelist, nzDefaults)
	jyvaskylaSongInsertCacheMut.RLock()
	cache, cached := jyvaskylaSongInsertCache[key]
	jyvaskylaSongInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := strmangle.InsertColumnSet(
			jyvaskylaSongColumns,
			jyvaskylaSongColumnsWithDefault,
			jyvaskylaSongColumnsWithoutDefault,
			nzDefaults,
			whitelist,
		)

		cache.valueMapping, err = queries.BindMapping(jyvaskylaSongType, jyvaskylaSongMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(jyvaskylaSongType, jyvaskylaSongMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `jyvaskyla_songs` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.IndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `jyvaskyla_songs` () VALUES ()"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `jyvaskyla_songs` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, jyvaskylaSongPrimaryKeyColumns))
		}

		if len(wl) != 0 {
			cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into jyvaskyla_songs")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == jyvaskylaSongMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRow(cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for jyvaskyla_songs")
	}

CacheNoHooks:
	if !cached {
		jyvaskylaSongInsertCacheMut.Lock()
		jyvaskylaSongInsertCache[key] = cache
		jyvaskylaSongInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// UpdateG a single JyvaskylaSong record. See Update for
// whitelist behavior description.
func (o *JyvaskylaSong) UpdateG(whitelist ...string) error {
	return o.Update(boil.GetDB(), whitelist...)
}

// UpdateGP a single JyvaskylaSong record.
// UpdateGP takes a whitelist of column names that should be updated.
// Panics on error. See Update for whitelist behavior description.
func (o *JyvaskylaSong) UpdateGP(whitelist ...string) {
	if err := o.Update(boil.GetDB(), whitelist...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpdateP uses an executor to update the JyvaskylaSong, and panics on error.
// See Update for whitelist behavior description.
func (o *JyvaskylaSong) UpdateP(exec boil.Executor, whitelist ...string) {
	err := o.Update(exec, whitelist...)
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// Update uses an executor to update the JyvaskylaSong.
// Whitelist behavior: If a whitelist is provided, only the columns given are updated.
// No whitelist behavior: Without a whitelist, columns are inferred by the following rules:
// - All columns are inferred to start with
// - All primary keys are subtracted from this set
// Update does not automatically update the record in case of default values. Use .Reload()
// to refresh the records.
func (o *JyvaskylaSong) Update(exec boil.Executor, whitelist ...string) error {
	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return err
	}
	key := makeCacheKey(whitelist, nil)
	jyvaskylaSongUpdateCacheMut.RLock()
	cache, cached := jyvaskylaSongUpdateCache[key]
	jyvaskylaSongUpdateCacheMut.RUnlock()

	if !cached {
		wl := strmangle.UpdateColumnSet(
			jyvaskylaSongColumns,
			jyvaskylaSongPrimaryKeyColumns,
			whitelist,
		)

		if len(whitelist) == 0 {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update jyvaskyla_songs, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `jyvaskyla_songs` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, jyvaskylaSongPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(jyvaskylaSongType, jyvaskylaSongMapping, append(wl, jyvaskylaSongPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err = exec.Exec(cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update jyvaskyla_songs row")
	}

	if !cached {
		jyvaskylaSongUpdateCacheMut.Lock()
		jyvaskylaSongUpdateCache[key] = cache
		jyvaskylaSongUpdateCacheMut.Unlock()
	}

	return o.doAfterUpdateHooks(exec)
}

// UpdateAllP updates all rows with matching column names, and panics on error.
func (q jyvaskylaSongQuery) UpdateAllP(cols M) {
	if err := q.UpdateAll(cols); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpdateAll updates all rows with the specified column values.
func (q jyvaskylaSongQuery) UpdateAll(cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.Exec()
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for jyvaskyla_songs")
	}

	return nil
}

// UpdateAllG updates all rows with the specified column values.
func (o JyvaskylaSongSlice) UpdateAllG(cols M) error {
	return o.UpdateAll(boil.GetDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (o JyvaskylaSongSlice) UpdateAllGP(cols M) {
	if err := o.UpdateAll(boil.GetDB(), cols); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpdateAllP updates all rows with the specified column values, and panics on error.
func (o JyvaskylaSongSlice) UpdateAllP(exec boil.Executor, cols M) {
	if err := o.UpdateAll(exec, cols); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o JyvaskylaSongSlice) UpdateAll(exec boil.Executor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), jyvaskylaSongPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `jyvaskyla_songs` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, jyvaskylaSongPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in jyvaskylaSong slice")
	}

	return nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *JyvaskylaSong) UpsertG(updateColumns []string, whitelist ...string) error {
	return o.Upsert(boil.GetDB(), updateColumns, whitelist...)
}

// UpsertGP attempts an insert, and does an update or ignore on conflict. Panics on error.
func (o *JyvaskylaSong) UpsertGP(updateColumns []string, whitelist ...string) {
	if err := o.Upsert(boil.GetDB(), updateColumns, whitelist...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpsertP attempts an insert using an executor, and does an update or ignore on conflict.
// UpsertP panics on error.
func (o *JyvaskylaSong) UpsertP(exec boil.Executor, updateColumns []string, whitelist ...string) {
	if err := o.Upsert(exec, updateColumns, whitelist...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
func (o *JyvaskylaSong) Upsert(exec boil.Executor, updateColumns []string, whitelist ...string) error {
	if o == nil {
		return errors.New("models: no jyvaskyla_songs provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(jyvaskylaSongColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs postgres problems
	buf := strmangle.GetBuffer()
	for _, c := range updateColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range whitelist {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	jyvaskylaSongUpsertCacheMut.RLock()
	cache, cached := jyvaskylaSongUpsertCache[key]
	jyvaskylaSongUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := strmangle.InsertColumnSet(
			jyvaskylaSongColumns,
			jyvaskylaSongColumnsWithDefault,
			jyvaskylaSongColumnsWithoutDefault,
			nzDefaults,
			whitelist,
		)

		update := strmangle.UpdateColumnSet(
			jyvaskylaSongColumns,
			jyvaskylaSongPrimaryKeyColumns,
			updateColumns,
		)
		if len(update) == 0 {
			return errors.New("models: unable to upsert jyvaskyla_songs, could not build update column list")
		}

		cache.query = queries.BuildUpsertQueryMySQL(dialect, "jyvaskyla_songs", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `jyvaskyla_songs` WHERE `id`=?",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
		)

		cache.valueMapping, err = queries.BindMapping(jyvaskylaSongType, jyvaskylaSongMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(jyvaskylaSongType, jyvaskylaSongMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for jyvaskyla_songs")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == jyvaskylaSongMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRow(cache.retQuery, identifierCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for jyvaskyla_songs")
	}

CacheNoHooks:
	if !cached {
		jyvaskylaSongUpsertCacheMut.Lock()
		jyvaskylaSongUpsertCache[key] = cache
		jyvaskylaSongUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// DeleteP deletes a single JyvaskylaSong record with an executor.
// DeleteP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *JyvaskylaSong) DeleteP(exec boil.Executor) {
	if err := o.Delete(exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// DeleteG deletes a single JyvaskylaSong record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *JyvaskylaSong) DeleteG() error {
	if o == nil {
		return errors.New("models: no JyvaskylaSong provided for deletion")
	}

	return o.Delete(boil.GetDB())
}

// DeleteGP deletes a single JyvaskylaSong record.
// DeleteGP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *JyvaskylaSong) DeleteGP() {
	if err := o.DeleteG(); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Delete deletes a single JyvaskylaSong record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *JyvaskylaSong) Delete(exec boil.Executor) error {
	if o == nil {
		return errors.New("models: no JyvaskylaSong provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), jyvaskylaSongPrimaryKeyMapping)
	sql := "DELETE FROM `jyvaskyla_songs` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from jyvaskyla_songs")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return err
	}

	return nil
}

// DeleteAllP deletes all rows, and panics on error.
func (q jyvaskylaSongQuery) DeleteAllP() {
	if err := q.DeleteAll(); err != nil {
		panic(boil.WrapErr(err))
	}
}

// DeleteAll deletes all matching rows.
func (q jyvaskylaSongQuery) DeleteAll() error {
	if q.Query == nil {
		return errors.New("models: no jyvaskylaSongQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.Exec()
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from jyvaskyla_songs")
	}

	return nil
}

// DeleteAllGP deletes all rows in the slice, and panics on error.
func (o JyvaskylaSongSlice) DeleteAllGP() {
	if err := o.DeleteAllG(); err != nil {
		panic(boil.WrapErr(err))
	}
}

// DeleteAllG deletes all rows in the slice.
func (o JyvaskylaSongSlice) DeleteAllG() error {
	if o == nil {
		return errors.New("models: no JyvaskylaSong slice provided for delete all")
	}
	return o.DeleteAll(boil.GetDB())
}

// DeleteAllP deletes all rows in the slice, using an executor, and panics on error.
func (o JyvaskylaSongSlice) DeleteAllP(exec boil.Executor) {
	if err := o.DeleteAll(exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o JyvaskylaSongSlice) DeleteAll(exec boil.Executor) error {
	if o == nil {
		return errors.New("models: no JyvaskylaSong slice provided for delete all")
	}

	if len(o) == 0 {
		return nil
	}

	if len(jyvaskylaSongBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), jyvaskylaSongPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `jyvaskyla_songs` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, jyvaskylaSongPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from jyvaskylaSong slice")
	}

	if len(jyvaskylaSongAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return err
			}
		}
	}

	return nil
}

// ReloadGP refetches the object from the database and panics on error.
func (o *JyvaskylaSong) ReloadGP() {
	if err := o.ReloadG(); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadP refetches the object from the database with an executor. Panics on error.
func (o *JyvaskylaSong) ReloadP(exec boil.Executor) {
	if err := o.Reload(exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadG refetches the object from the database using the primary keys.
func (o *JyvaskylaSong) ReloadG() error {
	if o == nil {
		return errors.New("models: no JyvaskylaSong provided for reload")
	}

	return o.Reload(boil.GetDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *JyvaskylaSong) Reload(exec boil.Executor) error {
	ret, err := FindJyvaskylaSong(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllGP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *JyvaskylaSongSlice) ReloadAllGP() {
	if err := o.ReloadAllG(); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAllP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *JyvaskylaSongSlice) ReloadAllP(exec boil.Executor) {
	if err := o.ReloadAll(exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *JyvaskylaSongSlice) ReloadAllG() error {
	if o == nil {
		return errors.New("models: empty JyvaskylaSongSlice provided for reload all")
	}

	return o.ReloadAll(boil.GetDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *JyvaskylaSongSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	jyvaskylaSongs := JyvaskylaSongSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), jyvaskylaSongPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `jyvaskyla_songs`.* FROM `jyvaskyla_songs` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, jyvaskylaSongPrimaryKeyColumns, len(*o))

	q := queries.Raw(exec, sql, args...)

	err := q.Bind(&jyvaskylaSongs)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in JyvaskylaSongSlice")
	}

	*o = jyvaskylaSongs

	return nil
}

// JyvaskylaSongExists checks if the JyvaskylaSong row exists.
func JyvaskylaSongExists(exec boil.Executor, id uint64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `jyvaskyla_songs` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, id)
	}

	row := exec.QueryRow(sql, id)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if jyvaskyla_songs exists")
	}

	return exists, nil
}

// JyvaskylaSongExistsG checks if the JyvaskylaSong row exists.
func JyvaskylaSongExistsG(id uint64) (bool, error) {
	return JyvaskylaSongExists(boil.GetDB(), id)
}

// JyvaskylaSongExistsGP checks if the JyvaskylaSong row exists. Panics on error.
func JyvaskylaSongExistsGP(id uint64) bool {
	e, err := JyvaskylaSongExists(boil.GetDB(), id)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// JyvaskylaSongExistsP checks if the JyvaskylaSong row exists. Panics on error.
func JyvaskylaSongExistsP(exec boil.Executor, id uint64) bool {
	e, err := JyvaskylaSongExists(exec, id)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}
